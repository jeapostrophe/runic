#include <iostream>
#include <string> // string
#include "superNode.h" // superNode

using namespace std;

bool __calc_superNode_space(runic_t r, string input) {
	bool status = false;
	uint64_t free, file_size;
	free = runic_free(r);
	file_size = r.sb.st_size;
	if ((free + SUPERNODE_MEMORY_SIZE + input.size()) < file_size) // two nodes and one atom + length
		status = true;
	return status;
}

superNode::superNode(runic_t &r, string input) {
	isempty = true;
	if (__calc_superNode_space(r, input) && r.base != NULL) {
		super_node = runic_alloc_node(&r);
		children = runic_alloc_node(&r);
		atom = runic_alloc_atom_str(&r, input.c_str());
		runic_node_set_left(&super_node, children);
		runic_node_set_right(&super_node, atom);
		isempty = false;
	}
}

superNode::superNode(runic_t &r) {
	isempty = true;
	if (r.base != NULL) { // valid file
		if ((runic_root(r)).offset >= DEFAULT_ROOT) { // valid node (assumed to be generated by a super node)
			super_node = runic_root(r);
			children = runic_node_left(super_node);
			atom = runic_node_right(super_node);
			if (super_node.offset	>= DEFAULT_ROOT // only valid if all objects check out correctly.
				&& children.offset	>= DEFAULT_ROOT
				&& atom.offset		>= DEFAULT_ROOT)
				isempty = false;
		}
	}
}

superNode superNode::left() const{
	runic_obj_t left = runic_node_left(children);	
		return superNode(left);  // constructor does safe build, no checks needed
}

superNode superNode::right() const{
	runic_obj_t right = runic_node_right(children);
		return superNode(right);
}

string superNode::read() const{
	char c[256];
	string none = "";
	if (!isempty && runic_atom_read(atom, c))
		return string(c);
	else
		return none;
}

bool superNode::balance() {
	return false;
}


int superNode::bf() const{ // returns current bf
	return balance_factor;
}

bool superNode::empty() const{
	return isempty;
}

int superNode::str_loc() const{
	return atom.offset;
}

bool superNode::set_left(superNode left) {
	bool status = false;
	if (left.isempty || this->isempty)
		return status;
	else
		return status = runic_node_set_left(&children, left.super_node);
}

bool superNode::set_right(superNode right) {
	bool status = false;
	if (right.isempty || this->isempty)
		return status;
	else
		return status = runic_node_set_left(&children, right.super_node);
}

bool superNode::write(string input) {
	return runic_atom_write(&atom, input.c_str());
}

bool superNode::set_root(runic_t &r) {
	bool status = false;
	if (r.base != NULL && !isempty)
		return status = runic_set_root(&r, super_node);
	else
		return status;
}

superNode::~superNode() {
	
}

///////// USER INACCESSABLE /////////

superNode::superNode() {
	isempty = true;
}

superNode::superNode(runic_obj_t node) {
	isempty = true;
	if (node.offset >= DEFAULT_ROOT) { // valid node (assumed to be generated by a super node)
		atom = runic_node_right(node);
		children = runic_node_left(node);
		super_node = node;
		if (super_node.offset	>= DEFAULT_ROOT // only valid if all objects check out correctly.
			&& children.offset	>= DEFAULT_ROOT
			&& atom.offset		>= DEFAULT_ROOT)
			isempty = false;
	}
}

bool superNode::set_bf(int new_bf) {
	if (!isempty)
		balance_factor = new_bf;
	
	return !isempty;
}
