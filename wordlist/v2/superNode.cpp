#include <iostream>
#include <string> // string
#include "superNode.h" // superNode

using namespace std;

bool __calc_superNode_space(runic_t r, string input)
{
	bool status = false;
	uint64_t free, file_size;
	free = runic_free(r);
	file_size = r.sb.st_size;
	if ((free + 0x13 + input.size()) < file_size)
		status = true;
	return status;
}

superNode::superNode(runic_t &r, string input) {
	isempty = true;
	if (__calc_superNode_space(r, input) && r.base != NULL)
	{
		super_node = runic_alloc_node(&r);
		child_carrier = runic_alloc_node(&r);
		atom = runic_alloc_atom_str(&r, input.c_str());
		runic_node_set_left(&super_node, child_carrier);
		runic_node_set_right(&super_node, atom);
		isempty = false;
	}
}

superNode::superNode(runic_t &r) {
	isempty = true;
	if (r.base != NULL) { // valid file
		if ((runic_root(r)).offset >= DEFAULT_ROOT) { // valid node (assumed to be generated by a super node)
			super_node = runic_root(r);
			child_carrier = runic_node_left(super_node);
			atom = runic_node_right(super_node);
			isempty = false;
		}
	}
}

superNode::superNode(runic_obj_t node) {
	atom = runic_node_right(node);
	child_carrier = runic_node_left(node);
	super_node = node;
}

superNode::~superNode() {
	
}

superNode superNode::left() {
	runic_obj_t left = runic_node_left(child_carrier);
        return superNode(left); }

superNode superNode::right() {
	runic_obj_t right = runic_node_right(child_carrier);
	return superNode(right);
}

string superNode::read() {
	char c[256];
	string none = "";
	if (!isempty && runic_atom_read(atom, c))
		return string(c);
	else
		return none;
}

int superNode::bf() { // returns current bf
	return balance_factor;
}

bool superNode::empty() {
	return isempty;
}

int superNode::str_loc() {
	return atom.offset;
}

bool superNode::set_bf(int new_bf) {
	if (!isempty)
		balance_factor = new_bf;
	
	return !isempty;
}

bool superNode::set_left(superNode left) {
	bool status = false;
	if (left.isempty || this->isempty)
		return status;
	else
		return status = runic_node_set_left(&child_carrier, left.super_node);
}

bool superNode::set_right(superNode right) {
	bool status = false;
	if (right.isempty || this->isempty)
		return status;
	else
		return status = runic_node_set_left(&child_carrier, right.super_node);
}

bool superNode::write(string input) {
	return runic_atom_write(&atom, input.c_str());
}

bool superNode::set_root(runic_t &r) {
	bool status = false;
	if (r.base != NULL && !isempty)
		return status = runic_set_root(&r, super_node);
	else
		return status;
}
